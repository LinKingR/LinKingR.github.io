<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2014 | 小林子的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="新的开始">
<meta property="og:type" content="website">
<meta property="og:title" content="小林子的博客">
<meta property="og:url" content="http://blog.linkingr/archives/2014/">
<meta property="og:site_name" content="小林子的博客">
<meta property="og:description" content="新的开始">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小林子的博客">
<meta name="twitter:description" content="新的开始">

  
    <link rel="alternative" href="/atom.xml" title="小林子的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">小林子的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://blog.linkingr"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/27/test/" class="article-date">
  <time datetime="2014-12-27T04:29:00.000Z" itemprop="datePublished">12月 27 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/27/test/">什么是爱情</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>2014年11月23日，我分手了，一年零七个月，568天的异地恋，最终两个人选择了分开。我们一个家在河北，一个家在海南，一个在北京工作，一个在郑州读书，在杭州旅游时相遇，一个月见一次，我们就这样，谈着没有任何基础的异地恋，快乐着，幸福着，憧憬过一起买菜的日子，向往着一起变老的爱情，可最后的最后，两个人还是没办法挣脱现实，还是忘记了说好的幸福。</p>
<p>也许你会说，两个人相距这么远，又是异地，分开也没什么，其实你说的对，对于我们这种完全没有任何基础的情侣，能坚持到底的异地恋情真的是很艰难。但是，这真的是我第一次付出真心的感情，分开的刺痛，像刀一样一下一下的戳着我的心，我不知道自己流了多少泪水，不知道多少个夜辗转反侧，但那有能怎样，现实没办法改变，爱情终将败给现实。</p>
<p>以前我总是想不清楚一件事，什么是喜欢，什么是爱，这次分开让我忽然想的特别明白，喜欢就会放肆，而爱就会克制，喜欢就是一种冲动，而爱就是一份坚守，喜欢就是我对你好，而爱就是我愿意为你放弃一切。所以那时候，你总说爱我，其实你只是喜欢我，喜欢阳光下的我，喜欢微笑的我，那时候，我也只是喜欢你，我带你去玩，给你买东西，但是我们都没上升到爱，在选择未来的时候，我们只考虑了自己，你说你不想来北京，你说你现在最主要的事情是课题，你说你凭什么要去讨好我的父母，我说为什么你不能考到北京，我说你为什么不能多花时间陪陪我，我说为什么你总是考虑你自己，这不是爱，<strong>爱是包容，是理解，是信任，是愿意为对方付出一切</strong>，而喜欢，就只是节日里我给你买个礼物，放假了我们一起去玩耍，爱是需要时间的，是慢慢喜欢而后变成的，当你觉得你愿意为这个人放弃你的所有的时候，你就爱上TA了。当我分开的时候，我发现我爱你，我什么都可以不要，但我不能失去你，只可惜已经来不及了。</p>
<p>爱情就是这样，你只有一次的机会，错过了，就算再找回来，也会变味了，就像你分开的时候对我说的那些话，就算再找回来，你的狠心和绝情还是烙在了我的心里，我会害怕有一天你还是会离开我，我害怕你在我父母那受到一点委屈，你就会受不了。你说你现在很忙，所以我愿意放你自由。</p>
<p>爱情，是在对的时间对的地点遇到对的人，对的时间，就是你二十五岁，经历了分开与伤害，懂得了珍惜，想要找一个相伴一生的人，对的地点，就是在一个城市，你决定在那里生活，你喜欢那里的生活，对的人，就是另外一个也刚好在对的时间，刚好在你在的城市，刚好又喜欢你的人。所以我们并不是合适的人，她并没有在对的时间，我们也没有在合适的地点，也许人是对的，但是现实太残酷，我们没办法克服，所以我们必然会分开。</p>
<p>最后我想说，<strong>如果爱，请深爱，能不分开，请不要分开</strong>。颖颖，祝你幸福，我会去我们相识的城市，重新开始，好好生活。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.linkingr/2014/12/27/test/" data-id="urhse9kl3b29phsg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Handler-and-Looper" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/06/18/Handler-and-Looper/" class="article-date">
  <time datetime="2014-06-18T06:38:07.000Z" itemprop="datePublished">6月 18 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/18/Handler-and-Looper/">Handler and Looper</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>安卓刚入门的时候就知道，系统为每个应用进程分配了一个主线程，也就是ui线程，我们也在一开始就会使用message与主线程进行通信，说起handler，looper，message甚至messageQuene，相信我们很多人都只知道并且会用，那么到底线程间通信究竟发生了什么事情，这里就来简单了解一下Handle和Looper。</p>
<p>这里首先要提到刚才提到的这四个类，Handler，Looper，Message以及MessageQueue，我们一个一个来看。</p>
<p>Handler：含义从字面意思来看是处理器，其实也是这样的，主要负责消息的发送和接受。</p>
<p>Handler提供了7个构造器，归结起来其实就是下面两个：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">Handler</span>(Callback callback, boolean <span class="keyword">async</span>) {</div><div class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) {</div><div class="line">        final Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&</div><div class="line">                (klass.getModifiers() & Modifier.STATIC) == <span class="number">0</span>) {</div><div class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        }</div><div class="line">    }</div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    }</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = <span class="keyword">async</span>;</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="title">Handler</span>(Looper looper, Callback callback, boolean <span class="keyword">async</span>) {</div><div class="line">    mLooper = looper;</div><div class="line">    mQueue = looper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = <span class="keyword">async</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到都是对四个变量进行初始化赋值，其中mLooper等下会讲，它表示当前线程的消息循环，mQueue表示MessageQueue消息队列，mCallback比较简单，就表示一个回调函数，mAsynchronous是一个boolean值，字面意思来看表示消息是否异步，它的作用我们等下看。</p>
<p>我们平时都是怎么使用Handler的呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Handler handler = <span class="keyword">new</span> Handler() {</div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> handleMessage(Message msg) {</div><div class="line">        <span class="comment">//做消息处理的操作</span></div><div class="line">    }</div><div class="line">}</div><div class="line">或者</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildHandler</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Handler</span> </span>{</div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> handleMessage(Message msg) {</div><div class="line">        <span class="comment">//做消息处理的操作</span></div><div class="line">    }</div><div class="line">}</div><div class="line">ChildHandler handler = <span class="keyword">new</span> ChindHandler();</div><div class="line">然后调用handler.sendMessage方法，在这个handleMessage中就会接收到Message，那么这样用是否正确呢？为什么有时候会遇到Can<span class="string">'t create handler inside thread that has not called Looper.prepare()这个崩溃呢？</span></div></pre></td></tr></table></figure>

<p>带着这个问题，就要了解Looper了，那么到底什么是Looper？</p>
<p>Looper定义：消息循环，单纯这个解释大家肯定还是不能理解，再说两个重要的特性：</p>
<p><strong>1.每一个线程都只有一个Looper和一个MessageQueue。</strong></p>
<p><strong>2.每个Handler都有它所归属的线程，如果要使用Handler必须初始化Looper。</strong>ui线程的Looper叫做MainLooper，它是一个不会停止的消息循环，由系统进行初始化。</p>
<p>第二点就是解释了为什么我们可以直接使用Handler发消息，是因为系统已经为你初始化了一个消息循环，而如果你在一个自己创建的线程中使用Handler，就一定会报刚才那个异常。</p>
<p>看一下Looper中的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span>(boolean quitAllowed) {</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.<span class="keyword">get</span>() != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    }</div><div class="line">    sThreadLocal.<span class="keyword">set</span>(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span>() {</div><div class="line">    prepare(<span class="keyword">false</span>);</div><div class="line">    synchronized (Looper.class) {</div><div class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">        }</div><div class="line">        sMainLooper = myLooper();</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span>() {</div><div class="line">    synchronized (Looper.class) {</div><div class="line">        <span class="keyword">return</span> sMainLooper;</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span>() {</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">myLooper</span>() {</div><div class="line">    <span class="keyword">return</span> sThreadLocal.<span class="keyword">get</span>();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到这里sThreadLocal是一个泛型类ThreadLocal<looper>，从它提供了set和put可以看出，它好像是一个列表，其实可以把它理解成一个特殊的map，使用set方法时，会把Looper信息与当前Thread信息绑定起来，使用get方法又会把当前线程对应的Looper取出来。</looper></p>
<p>prepareMainLooper是在应用进程初始化的过程中调用的，所以我们不可以再次调用。当你初始化一个线程时，它本身是不带消息循环的，比如主线程可以处理各个线程发来的消息，但是你new的这个线程，如果什么都不做，是无法接收消息的，那么如何把一个普通线程转化为一个Looper线程呢？看下面一段代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="at_rule">@Override<span class="preprocessor"></span></span></div><div class="line">public<span class="preprocessor"> void</span><span class="preprocessor"> run</span>() {</div><div class="line">    <span class="comment">// 将当前线程初始化为Looper线程</span></div><div class="line">    <span class="comment">// Looper.prepare();</span></div><div class="line">     </div><div class="line">    <span class="comment">// ...其他处理，如实例化handler</span></div><div class="line">    1<span class="value">: Handler handler = new <span class="function">Handler</span>();</span></div><div class="line">    2<span class="value">: Hanlder handler = new <span class="function">Handler</span>(Looper.<span class="function">getMainLooper</span>());</span></div><div class="line">    3<span class="value">: Hanlder handler = new <span class="function">Handler</span>(Looper.<span class="function">myLooper</span>());</span></div><div class="line">     </div><div class="line">    <span class="comment">// 开始循环处理消息队列</span></div><div class="line">    <span class="comment">// Looper.loop();</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到这里注释的代码，就是把一个线程变成Looper线程的关键代码，如果这两行代码被注释，1和3的初始化都会异常，而2会正常，因为2传入Handler的是主线程Looper，这样其实相当于Handler是在主线程中，跟当前线程无关，而1和3表示Handler处于当前线程中，必须在Handler初始化之前调用prepare()，并在之后开启消息循环。这样Handler才能接收和处理消息。Looper线程的Handler初始化也可以放在ui线程中，但必须在Looper线程start之后，并且将thread.getLooper()传入Handler中。</p>
<p>通过以上可以看出，Handler的归属线程取决于你传入的Looper是在哪个线程，如果不传，就是当前线程。<br>接下来，就需要分析消息循环和消息队列了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public static void loop() { //有部分代码被我省略</div><div class="line">    final Looper me = myLooper(); //取出当前Looper</div><div class="line">    <span class="keyword">if</span> (me == null) {</div><div class="line">        throw new RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    }</div><div class="line">    final MessageQueue queue = me.mQueue; //从Looper中取出消息队列</div><div class="line">    <span class="keyword">...</span></div><div class="line">    <span class="keyword">for</span> (;;) { //开始循环</div><div class="line">        Message msg = queue.next(); // 从消息队列中读出下一条消息</div><div class="line">        <span class="keyword">if</span> (msg == null) {</div><div class="line">            // 如果消息为空表示当前消息循环结束，这里注意一下，不是没有消息的时候Looper就结束，因为上一行的<span class="keyword">next</span>方法是block的，只有在调用quit方法的情况下才会返回空消息</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">...</span></div><div class="line">        msg.target.dispatchMessage(msg); //消息的回调处理，target表示Handler</div><div class="line">        <span class="keyword">...</span></div><div class="line">        msg.recycle();//消息回收</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从上面代码可以看出，Looper开启消息循环后，会进入一个死循环，注意这里不是无限循环哦，next这个方法是会block线程的，也就是当有消息的时候next方法才会返回message并且处理它，没有消息就不返回卡住啦，所以你一定好奇next里面做了什么，来看～</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">Message <span class="keyword">next</span>() {</div><div class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>;  <span class="comment">//idleHandler这个东西很有意思，它在每次调用next读取消息的之前会让你做一些你想做的操作，等下看</span></div><div class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>; <span class="comment">//字面理解是下一次的一个超时时间，它其实的意思是消息延迟，比如说你发了一个3秒后才会响应的消息，就是从这个int值体现的</span></div><div class="line">        <span class="keyword">for</span> (;;) { <span class="comment">//进入循环</span></div><div class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) {</div><div class="line">                Binder.flushPendingCommands(); <span class="comment">//不知道干嘛的</span></div><div class="line">            }</div><div class="line">             </div><div class="line">            nativePollOnce(mPtr, nextPollTimeoutMillis); <span class="comment">//native方法，这个方法叼啦，它最重要的作用就是把线程block住，两种情况会让block结束，1.这里传入的超时时间。2.某些主动触发。</span></div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">                Message prevMsg = <span class="keyword">null</span>;</div><div class="line">                Message msg = mMessages; </div><div class="line"><span class="comment">//MessageQueue里面有个mMessages，它是个Message，表示当前需要处理的消息，那么消息队列从何而来呢？在Message里面，是我们大学里写过太多的c链表，在Message里面有个next的Message对象，指向下一个Message，所以这是一个单向链表，并且按照Message的时间顺序。</span></div><div class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> && msg.target == <span class="keyword">null</span>) { </div><div class="line"><span class="comment">//记不记得刚才说过mAsynchronous这个东西，它就在这里起作用了，Looper里面提供一个方法postSyncBarrier()，它的意思是设置一个</span></div><div class="line">Barrier，它也是一个消息，但是是一个没有target的消息，执行postSyncBarrier方法会把它放置在消息队列中，这里就是对这种消息进行处理，当处理到这样的消息时，就会阻塞其他消息，只有mAsynchronous设为<span class="keyword">true</span>的才会处理，其他消息处于等待。如果没有设置Barrier则mAsynchronous和这里的代码都没有意义。</div><div class="line">                    <span class="keyword">do</span> {</div><div class="line">                        prevMsg = msg;</div><div class="line">                        msg = msg.<span class="keyword">next</span>;</div><div class="line">                    } <span class="keyword">while</span> (msg != <span class="keyword">null</span> && !msg.isAsynchronous());<span class="comment">//找到第一个isAsynchronous为true的消息</span></div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) {<span class="comment">// 得到当前需要处理的消息，一般是队列的第一条，也有可能不是。</span></div><div class="line">                    <span class="keyword">if</span> (now &lt; msg.when) { <span class="comment">//如果当前时间小于消息时间，就设置一个超时</span></div><div class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                    } <span class="keyword">else</span> { <span class="comment">//将需要处理的消息返回</span></div><div class="line">                        mBlocked = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) {</div><div class="line">                            prevMsg.<span class="keyword">next</span> = msg.<span class="keyword">next</span>;</div><div class="line">                        } <span class="keyword">else</span> {</div><div class="line">                            mMessages = msg.<span class="keyword">next</span>;</div><div class="line">                        }</div><div class="line">                        msg.<span class="keyword">next</span> = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                        msg.markInUse();</div><div class="line">                        <span class="keyword">return</span> msg;</div><div class="line">                    }</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>; <span class="comment">//nextPollTimeoutMillis设未-1表示无限delay，只能通过其他触发</span></div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (mQuitting) {</div><div class="line">                    dispose();</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//只有quit的时候才会返回null</span></div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></div><div class="line">                        && (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) { <span class="comment">//当pendingIdleHandlerCount为-1也就是上次消息循环结束，又进入next方法等待消息并且当前没有Message需要处理时，会把mIdleHandlers里注册的Handler执行一遍，注意这里在每一次next进入到return结果只会执行一遍。</span></div><div class="line">                    pendingIdleHandlerCount = mIdleHandlers.<span class="keyword">size</span>();</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) {</div><div class="line">                    mBlocked = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">continue</span>; <span class="comment">//没有的话就直接继续循环</span></div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) {</div><div class="line">                    mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</div><div class="line">                }</div><div class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">            }</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) {</div><div class="line">                <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">                mPendingIdleHandlers[i] = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    keep = idler.queueIdle();</div><div class="line">                } <span class="keyword">catch</span> (Throwable t) {</div><div class="line">                    Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (!keep) {</div><div class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">                        mIdleHandlers.remove(idler);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">            pendingIdleHandlerCount = <span class="number">0</span>;</div><div class="line">            nextPollTimeoutMillis = <span class="number">0</span>;<span class="comment">//执行之后，会初始化nextPollTimeoutMillis＝0是因为系统认为这个执行过程中有可能会有新的消息插入了，所以需要再重新取一遍消息</span></div><div class="line">        }</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>所以可以看到这个核心函数的关键在于nativePollOnce方法的block，可以这样理解它，每次next都一定会取到一个Message，里面会有一个无限循环，取到当前队列中的第一个需要处理的Message，如果为空，则表示当前消息队列未空，设置nextPollTimeoutMillis为-1，线程无限block，需要通过其他方式唤醒，如果不为空，则判断时间是否已到，没有到就会在算出timeout的时间，否则就将Message返回，然后处理消息，再进入下一次next循环处理消息的生命周期中。</p>
<p>对于消息循环和消息队列理解清楚了，就差最后一步了，发消息的时候发生了什么呢？<br>首先讲一下Message，含义是消息，Message要讲的就是里面的一个静态变量Message，Message本身会维护一个链表，用来保存那些被处理过的消息，可以进行复用，所以我们尽量不要用new Message的方法来使用Message，而尽量使用Message.obtain系列方法，它会对已回收的Message进行复用，减少内存开销，如果每次都new Message，就会把这个回收的链表整的很长。</p>
<p>我们使用Message.obtain(handler).sendToTarget()方法，handler.sendEmptyMessage系列方法或者post(Runnable)方法发送消息最后所有的方法都会走到一个sendMessageAtTime(Message msg, long uptimeMillis)方法中，最后都会调用到enqueueMessage，这是MessageQuene中的方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> enqueueMessage(Message msg, <span class="keyword">long</span> when) {</div><div class="line">    <span class="keyword">if</span> (msg.isInUse()) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Message must have a target."</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">        <span class="keyword">if</span> (mQuitting) {</div><div class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">            Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">boolean</span> needWake;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) { <span class="comment">//当前mMessages为空或者传入的msg处理时间小于mMessages的处理时间，就把它放在mMessages的前面</span></div><div class="line">            msg.<span class="keyword">next</span> = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;<span class="comment">// mBlocked标志当前是否处于block状态，如果处于block状态就需要唤醒。</span></div><div class="line">        } <span class="keyword">else</span> { <span class="comment">//当前队列不为空，并且需要处理的消息时间延后，则找到这个消息所属的位置，将其插入</span></div><div class="line">            needWake = mBlocked && p.target == <span class="keyword">null</span> && msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">            <span class="keyword">for</span> (;;) {</div><div class="line">                prev = p;</div><div class="line">                p = p.<span class="keyword">next</span>;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) { <span class="comment">//找到，退出</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (needWake && p.isAsynchronous()) {</div><div class="line">                    needWake = <span class="keyword">false</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            msg.<span class="keyword">next</span> = p; <span class="comment">//将msg插入到p和prev之间</span></div><div class="line">            prev.<span class="keyword">next</span> = msg;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (needWake) {</div><div class="line">            nativeWake(mPtr); <span class="comment">//这个native方法对应于nativePollOnce，会将这个方法唤醒并返回。</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样看来是不是就清楚了，handler的send只负责向消息队列中插入消息，并通知native层，我有消息啦，Looper负责消息循环，查询当前是否有消息需要处理，如果有就返回，如果没有就等待通知。</p>
<p>那么现在还有一个问题，这个block为什么不会block ui线程呢？其实并不是不block ui线程，而是因为ui线程本身就是block的。看系统是怎么做的？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Looper<span class="built_in">.</span>prepareMainLooper();</div><div class="line">ActivityThread <span class="keyword">thread</span> <span class="subst">=</span> <span class="literal">new</span> ActivityThread();</div><div class="line"><span class="keyword">thread</span><span class="built_in">.</span>attach(<span class="literal">false</span>);</div><div class="line"><span class="keyword">if</span> (sMainThreadHandler <span class="subst">==</span> <span class="built_in">null</span>) {</div><div class="line">    sMainThreadHandler <span class="subst">=</span> <span class="keyword">thread</span><span class="built_in">.</span>getHandler();</div><div class="line">}</div><div class="line">AsyncTask<span class="built_in">.</span>init();</div><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) {</div><div class="line">    Looper<span class="built_in">.</span>myLooper()<span class="built_in">.</span>setMessageLogging(<span class="literal">new</span></div><div class="line">            LogPrinter(<span class="keyword">Log</span><span class="built_in">.</span>DEBUG, <span class="string">"ActivityThread"</span>));</div><div class="line">}</div><div class="line">Looper<span class="built_in">.</span><span class="keyword">loop</span>();</div><div class="line">throw <span class="literal">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</div></pre></td></tr></table></figure>

<p>其实主线程就是一个被block住的线程，这个sMainHandler是一个很庞大的handler，里面包含了对activity，service等系统组件的控制，所以可以看到，其实所有比如页面开启、结束，内存回收，服务开启、绑定等等的操作，你的每一次点击，滑动都是通过消息触发并执行的，消息触发机制实现了整个安卓交互的过程，这点是不是很叼！</p>
<p><img src="http://d.pcs.baidu.com/thumbnail/00ce2c7a7fc70621c9d0c2b7c2a60f4b?fid=2265868045-250528-236330621244287&amp;time=1419667200&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-USvobe%2FEcC3jN9sSzktqs1zHZgY%3D&amp;rt=sh&amp;expires=2h&amp;r=516646235&amp;sharesign=unknown&amp;size=c710_u500&amp;quality=100" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.linkingr/2014/06/18/Handler-and-Looper/" data-id="n34mhkobntnfbqip" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Loaders" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/05/07/Loaders/" class="article-date">
  <time datetime="2014-05-07T08:20:13.000Z" itemprop="datePublished">5月 7 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/07/Loaders/">Loaders</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="背景">背景</h3>
<p>Loader3.0被引入安卓，使得在页面中异步数据加载变得更加容易，生命周期管理更加方便，不会再出现页面结束后数据回调的问题，接口简单易用。</p>
<p>support包中提供了Loader对低版本的支持，接下来就简单讲一下Loader在support包中的实现和用法。</p>
<h3 id="如何使用">如何使用</h3>
<p>在每个activity和fragment里面，只有一个LoaderManager，可以通过getLoaderManager得到</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">LoaderManagerImpl getLoaderManager(<span class="built_in">String</span> who, <span class="built_in">boolean</span> started, <span class="built_in">boolean</span> create) {</div><div class="line">        <span class="keyword">if</span> (mAllLoaderManagers == <span class="literal">null</span>) {</div><div class="line">            mAllLoaderManagers = <span class="keyword">new</span> SimpleArrayMap&lt;<span class="built_in">String</span>, LoaderManagerImpl&gt;();</div><div class="line">        }</div><div class="line">        LoaderManagerImpl lm = mAllLoaderManagers.get(who);</div><div class="line">        <span class="keyword">if</span> (lm == <span class="literal">null</span>) {</div><div class="line">            <span class="keyword">if</span> (create) {</div><div class="line">                lm = <span class="keyword">new</span> LoaderManagerImpl(who, <span class="keyword">this</span>, started);</div><div class="line">                mAllLoaderManagers.put(who, lm);</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            lm.updateActivity(<span class="keyword">this</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> lm;</div><div class="line">    }</div><div class="line">这是fragmentActivity中的一段代码，其中维护了一个map，用who做key，这个activity以及所有的子fragment的LoaderManager都会放在这个map中其中actvity的key为(root),fragment的key为(root):index</div></pre></td></tr></table></figure>

<p>那么如何启动一个Loader呢？</p>
<p>需要这句话getLoaderManager().initLoader(0, null, this);一般放在onCreate或onActivityCreated里面</p>
<p>其中第一个参数是id，第二个参数是bundle，bundle参数会传递到onCreateLoader方法里面，第三个参数是LoaderManager.LoaderCallbacks回调接口。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;D&gt; Loader&lt;D&gt; <span class="title">initLoader</span>(<span class="keyword">int</span> id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback) {</div><div class="line">    <span class="keyword">if</span> (mCreatingLoader) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Called while creating a loader"</span>);</div><div class="line">    }</div><div class="line">     </div><div class="line">    LoaderInfo info = mLoaders.<span class="keyword">get</span>(id);</div><div class="line">     </div><div class="line">    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"initLoader in "</span> + <span class="keyword">this</span> + <span class="string">": args="</span> + args);</div><div class="line">    <span class="keyword">if</span> (info == <span class="keyword">null</span>) {</div><div class="line">        <span class="comment">// Loader doesn't already exist; create.</span></div><div class="line">        info = createAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);</div><div class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Created new loader "</span> + info);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Re-using existing loader "</span> + info);</div><div class="line">        info.mCallbacks = (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback;</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">if</span> (info.mHaveData && mStarted) {</div><div class="line">        <span class="comment">// If the loader has already generated its data, report it now.</span></div><div class="line">        info.callOnLoadFinished(info.mLoader, info.mData);</div><div class="line">    }</div><div class="line">     </div><div class="line">    <span class="keyword">return</span> (Loader&lt;D&gt;)info.mLoader;</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">private</span> LoaderInfo <span class="title">createLoader</span>(<span class="keyword">int</span> id, Bundle args,</div><div class="line">        LoaderManager.LoaderCallbacks&lt;Object&gt; callback) {</div><div class="line">    LoaderInfo info = <span class="keyword">new</span> LoaderInfo(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);</div><div class="line">    Loader&lt;Object&gt; loader = callback.onCreateLoader(id, args);</div><div class="line">    info.mLoader = (Loader&lt;Object&gt;)loader;</div><div class="line">    <span class="keyword">return</span> info;</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">private</span> LoaderInfo <span class="title">createAndInstallLoader</span>(<span class="keyword">int</span> id, Bundle args,</div><div class="line">        LoaderManager.LoaderCallbacks&lt;Object&gt; callback) {</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        mCreatingLoader = <span class="keyword">true</span>;</div><div class="line">        LoaderInfo info = createLoader(id, args, callback);</div><div class="line">        installLoader(info);</div><div class="line">        <span class="keyword">return</span> info;</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        mCreatingLoader = <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">void</span> installLoader(LoaderInfo info) {</div><div class="line">    mLoaders.put(info.mId, info);</div><div class="line">    <span class="keyword">if</span> (mStarted) {</div><div class="line">        <span class="comment">// The activity will start all existing loaders in it's onStart(),</span></div><div class="line">        <span class="comment">// so only start them here if we're past that point of the activitiy's</span></div><div class="line">        <span class="comment">// life cycle</span></div><div class="line">        info.start();</div><div class="line">    }</div><div class="line">}</div><div class="line">createLoader方法中会调用callback对象的onCreateLoader方法创建Loader，并将它加入到当前LoaderManager维护的以id为key的map中，并开启start。</div><div class="line"><span class="keyword">void</span> start() {</div><div class="line">        <span class="keyword">if</span> (mRetaining && mRetainingStarted) {</div><div class="line">            <span class="comment">// Our owner is started, but we were being retained from a</span></div><div class="line">            <span class="comment">// previous instance in the started state...  so there is really</span></div><div class="line">            <span class="comment">// nothing to do here, since the loaders are still started.</span></div><div class="line">            mStarted = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (mStarted) {</div><div class="line">            <span class="comment">// If loader already started, don't restart.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        mStarted = <span class="keyword">true</span>;</div><div class="line">         </div><div class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Starting: "</span> + <span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (mLoader == <span class="keyword">null</span> && mCallbacks != <span class="keyword">null</span>) {</div><div class="line">           mLoader = mCallbacks.onCreateLoader(mId, mArgs);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (mLoader != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">if</span> (mLoader.getClass().isMemberClass()</div><div class="line">                    && !Modifier.isStatic(mLoader.getClass().getModifiers())) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                        <span class="string">"Object returned from onCreateLoader must not be a non-static inner member class: "</span></div><div class="line">                        + mLoader);</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (!mListenerRegistered) {</div><div class="line">                mLoader.registerListener(mId, <span class="keyword">this</span>);</div><div class="line">                mListenerRegistered = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">            mLoader.startLoading();</div><div class="line">        }</div><div class="line">    }</div><div class="line">start方法中调用了Loader的startLoading方法，这时候就会回调Loader实现类的onStartLoading方法。</div></pre></td></tr></table></figure>

<p>可以看到如果Loader存在，initLoader是会直接返回当前Loader数据，而不会重新走Loader的startLoading，那么restartLoader是怎么用的呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="subst">&lt;</span>D<span class="subst">&gt;</span> Loader<span class="subst">&lt;</span>D<span class="subst">&gt;</span> restartLoader(int id, Bundle args, LoaderManager<span class="built_in">.</span>LoaderCallbacks<span class="subst">&lt;</span>D<span class="subst">&gt;</span> callback) {</div><div class="line">        <span class="keyword">if</span> (mCreatingLoader) {</div><div class="line">            throw <span class="literal">new</span> IllegalStateException(<span class="string">"Called while creating a loader"</span>);</div><div class="line">        }</div><div class="line">         </div><div class="line">        LoaderInfo info <span class="subst">=</span> mLoaders<span class="built_in">.</span>get(id);</div><div class="line">        <span class="keyword">if</span> (DEBUG) <span class="keyword">Log</span><span class="built_in">.</span>v(<span class="built_in">TAG</span>, <span class="string">"restartLoader in "</span> <span class="subst">+</span> this <span class="subst">+</span> <span class="string">": args="</span> <span class="subst">+</span> args);</div><div class="line">        <span class="keyword">if</span> (info <span class="subst">!=</span> <span class="built_in">null</span>) {</div><div class="line">            LoaderInfo inactive <span class="subst">=</span> mInactiveLoaders<span class="built_in">.</span>get(id);</div><div class="line">            <span class="keyword">if</span> (inactive <span class="subst">!=</span> <span class="built_in">null</span>) {</div><div class="line">                <span class="keyword">if</span> (info<span class="built_in">.</span>mHaveData) {</div><div class="line">                    <span class="comment">// This loader now has data...  we are probably being</span></div><div class="line">                    <span class="comment">// called from within onLoadComplete, where we haven't</span></div><div class="line">                    <span class="comment">// yet destroyed the last inactive loader.  So just do</span></div><div class="line">                    <span class="comment">// that now.</span></div><div class="line">                    <span class="keyword">if</span> (DEBUG) <span class="keyword">Log</span><span class="built_in">.</span>v(<span class="built_in">TAG</span>, <span class="string">"  Removing last inactive loader: "</span> <span class="subst">+</span> info);</div><div class="line">                    inactive<span class="built_in">.</span>mDeliveredData <span class="subst">=</span> <span class="literal">false</span>;</div><div class="line">                    inactive<span class="built_in">.</span>destroy();</div><div class="line">                    info<span class="built_in">.</span>mLoader<span class="built_in">.</span>abandon();</div><div class="line">                    mInactiveLoaders<span class="built_in">.</span>put(id, info);</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    <span class="comment">// We already have an inactive loader for this ID that we are</span></div><div class="line">                    <span class="comment">// waiting for!  What to do, what to do...</span></div><div class="line">                    <span class="keyword">if</span> (<span class="subst">!</span>info<span class="built_in">.</span>mStarted) {</div><div class="line">                        <span class="comment">// The current Loader has not been started...  we thus</span></div><div class="line">                        <span class="comment">// have no reason to keep it around, so bam, slam,</span></div><div class="line">                        <span class="comment">// thank-you-ma'am.</span></div><div class="line">                        <span class="keyword">if</span> (DEBUG) <span class="keyword">Log</span><span class="built_in">.</span>v(<span class="built_in">TAG</span>, <span class="string">"  Current loader is stopped; replacing"</span>);</div><div class="line">                        mLoaders<span class="built_in">.</span>put(id, <span class="built_in">null</span>);</div><div class="line">                        info<span class="built_in">.</span>destroy();</div><div class="line">                    } <span class="keyword">else</span> {</div><div class="line">                        <span class="comment">// Now we have three active loaders... we'll queue</span></div><div class="line">                        <span class="comment">// up this request to be processed once one of the other loaders</span></div><div class="line">                        <span class="comment">// finishes.</span></div><div class="line">                        <span class="keyword">if</span> (info<span class="built_in">.</span>mPendingLoader <span class="subst">!=</span> <span class="built_in">null</span>) {</div><div class="line">                            <span class="keyword">if</span> (DEBUG) <span class="keyword">Log</span><span class="built_in">.</span>v(<span class="built_in">TAG</span>, <span class="string">"  Removing pending loader: "</span> <span class="subst">+</span> info<span class="built_in">.</span>mPendingLoader);</div><div class="line">                            info<span class="built_in">.</span>mPendingLoader<span class="built_in">.</span>destroy();</div><div class="line">                            info<span class="built_in">.</span>mPendingLoader <span class="subst">=</span> <span class="built_in">null</span>;</div><div class="line">                        }</div><div class="line">                        <span class="keyword">if</span> (DEBUG) <span class="keyword">Log</span><span class="built_in">.</span>v(<span class="built_in">TAG</span>, <span class="string">"  Enqueuing as new pending loader"</span>);</div><div class="line">                        info<span class="built_in">.</span>mPendingLoader <span class="subst">=</span> createLoader(id, args,</div><div class="line">                                (LoaderManager<span class="built_in">.</span>LoaderCallbacks<span class="subst">&lt;</span>Object<span class="subst">&gt;</span>)callback);</div><div class="line">                        <span class="keyword">return</span> (Loader<span class="subst">&lt;</span>D<span class="subst">&gt;</span>)info<span class="built_in">.</span>mPendingLoader<span class="built_in">.</span>mLoader;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">// Keep track of the previous instance of this loader so we can destroy</span></div><div class="line">                <span class="comment">// it when the new one completes.</span></div><div class="line">                <span class="keyword">if</span> (DEBUG) <span class="keyword">Log</span><span class="built_in">.</span>v(<span class="built_in">TAG</span>, <span class="string">"  Making last loader inactive: "</span> <span class="subst">+</span> info);</div><div class="line">                info<span class="built_in">.</span>mLoader<span class="built_in">.</span>abandon();</div><div class="line">                mInactiveLoaders<span class="built_in">.</span>put(id, info);</div><div class="line">            }</div><div class="line">        }</div><div class="line">         </div><div class="line">        info <span class="subst">=</span> createAndInstallLoader(id, args,  (LoaderManager<span class="built_in">.</span>LoaderCallbacks<span class="subst">&lt;</span>Object<span class="subst">&gt;</span>)callback);</div><div class="line">        <span class="keyword">return</span> (Loader<span class="subst">&lt;</span>D<span class="subst">&gt;</span>)info<span class="built_in">.</span>mLoader;</div><div class="line">    }</div><div class="line">mInactiveLoaders的意思表示之前运行过的Loader，这里主要做的事情是吧当前Loader的数据abandon掉，并且将其移入旧的Loader列表，然后创建新的Loader并运行。</div><div class="line">所以这种情况是会重新走onCreateLoader的。</div><div class="line">有一种情况很有意思，就是如果它发现之前的Loader已经开启，但还没有获取数据，就会重新开启一个新的pendingLoader，这个Loader其实和那个Loader的id是一样的。</div></pre></td></tr></table></figure>

<p>那么Loader是怎样获取数据的呢？一般都是继承Loader并实现其中的方法，我以AsyncTaskLoader为例讲解，CursorLoader我用的不多，但是官方文档上是以CursorLoader为例进行讲解的，有兴趣的同学可以看看。</p>
<p>那么说到了onStartLoading的回调，AsyncTaskLoader并没有重写这个方法，所以必须由它的子类重写该方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    <span class="keyword">protected</span> <span class="literal">void</span> onStartLoading() {</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">data</span> <span class="subst">!=</span> <span class="built_in">null</span>) {</div><div class="line">            deliverResult(<span class="built_in">data</span>);</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (takeContentChanged() <span class="subst">||</span> <span class="built_in">data</span> <span class="subst">==</span> <span class="built_in">null</span>) {</div><div class="line">            forceLoad();</div><div class="line">        }</div><div class="line">    }</div><div class="line">这个方法是在AsyncTaskLoader的子类里实现的，我们使用的时候takeContentChange一定是<span class="literal">false</span>，因为我们没有用过ContentObserver，可以看CursorLoader的源码，里面有一个registeContentObserver的方法，当对应URI的数据源发生变化时，observer会调用onContentChange修改这个方法，实现数据的重新加载。</div><div class="line">     </div><div class="line">    @Override</div><div class="line">    <span class="keyword">protected</span> <span class="literal">void</span> onForceLoad() {</div><div class="line">        super<span class="built_in">.</span>onForceLoad();</div><div class="line">        cancelLoad();</div><div class="line">        mTask <span class="subst">=</span> <span class="literal">new</span> LoadTask();</div><div class="line">        <span class="keyword">if</span> (DEBUG) <span class="keyword">Log</span><span class="built_in">.</span>v(<span class="built_in">TAG</span>, <span class="string">"Preparing load: mTask="</span> <span class="subst">+</span> mTask);</div><div class="line">        executePendingTask();</div><div class="line">    }</div><div class="line">这里会首先cancel掉之前的task，然后创建一个新的task并开启这个task，这个task就是之前讲过的AsyncTask，所以这里也会开启一个后台线程，运行loadInBackground方法并返回数据。</div><div class="line">当数据加载结束后通过这个方法进行回调</div><div class="line"> <span class="literal">void</span> dispatchOnLoadComplete(LoadTask task, D <span class="built_in">data</span>) {</div><div class="line">        <span class="keyword">if</span> (mTask <span class="subst">!=</span> task) {</div><div class="line">            <span class="keyword">if</span> (DEBUG) <span class="keyword">Log</span><span class="built_in">.</span>v(<span class="built_in">TAG</span>, <span class="string">"Load complete of old task, trying to cancel"</span>);</div><div class="line">            dispatchOnCancelled(task, <span class="built_in">data</span>);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">if</span> (isAbandoned()) {</div><div class="line">                <span class="comment">// This cursor has been abandoned; just cancel the new data.</span></div><div class="line">                onCanceled(<span class="built_in">data</span>);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                commitContentChanged();</div><div class="line">                mLastLoadCompleteTime <span class="subst">=</span> SystemClock<span class="built_in">.</span>uptimeMillis();</div><div class="line">                mTask <span class="subst">=</span> <span class="built_in">null</span>;</div><div class="line">                <span class="keyword">if</span> (DEBUG) <span class="keyword">Log</span><span class="built_in">.</span>v(<span class="built_in">TAG</span>, <span class="string">"Delivering result"</span>);</div><div class="line">                deliverResult(<span class="built_in">data</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">这里的deliverResult用来返回数据，回调到callback的onLoadFinished方法，注意这里的<span class="built_in">data</span>是有可能为空的。</div></pre></td></tr></table></figure>

<p>那么callback方法中还剩下一个onLoaderReset方法，它是怎么使用的呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">void destroy() {</div><div class="line">            <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Destroying: "</span> + this);</div><div class="line">            <span class="variable">mDestroyed =</span> <span class="constant">true</span>;</div><div class="line">            boolean <span class="variable">needReset =</span> mDeliveredData;</div><div class="line">            <span class="variable">mDeliveredData =</span> <span class="constant">false</span>;</div><div class="line">            <span class="keyword">if</span> (mCallbacks != <span class="constant">null</span> && mLoader != <span class="constant">null</span> && mHaveData && needReset) {</div><div class="line">                <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Reseting: "</span> + this);</div><div class="line">                String <span class="variable">lastBecause =</span> <span class="constant">null</span>;</div><div class="line">                <span class="keyword">if</span> (mActivity != <span class="constant">null</span>) {</div><div class="line">                    <span class="variable">lastBecause =</span> mActivity.mFragments.mNoTransactionsBecause;</div><div class="line">                    mActivity.mFragments.<span class="variable">mNoTransactionsBecause =</span> <span class="string">"onLoaderReset"</span>;</div><div class="line">                }</div><div class="line">                try {</div><div class="line">                    mCallbacks.onLoaderReset(mLoader);</div><div class="line">                } finally {</div><div class="line">                    <span class="keyword">if</span> (mActivity != <span class="constant">null</span>) {</div><div class="line">                        mActivity.mFragments.<span class="variable">mNoTransactionsBecause =</span> lastBecause;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="variable">mCallbacks =</span> <span class="constant">null</span>;</div><div class="line">            <span class="variable">mData =</span> <span class="constant">null</span>;</div><div class="line">            <span class="variable">mHaveData =</span> <span class="constant">false</span>;</div><div class="line">            <span class="keyword">if</span> (mLoader != <span class="constant">null</span>) {</div><div class="line">                <span class="keyword">if</span> (mListenerRegistered) {</div><div class="line">                    <span class="variable">mListenerRegistered =</span> <span class="constant">false</span>;</div><div class="line">                    mLoader.unregisterListener(this);</div><div class="line">                }</div><div class="line">                mLoader.reset();</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (mPendingLoader != <span class="constant">null</span>) {</div><div class="line">                mPendingLoader.destroy();</div><div class="line">            }</div><div class="line">        }</div><div class="line">可以看到它出现在了destory方法里面，在fragment的onDestroy方法会调用所有Loader的destory方法，相当于当前Loader被销毁，这时候才会调用reset，所以这个方法一般没有用，或者做一些数据清除的操作。</div></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.linkingr/2014/05/07/Loaders/" data-id="8fdvn7oxs8b9camh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-AsyncTask" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/04/24/AsyncTask/" class="article-date">
  <time datetime="2014-04-24T07:49:29.000Z" itemprop="datePublished">4月 24 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/24/AsyncTask/">AsyncTask</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="AsyncTask的定义">AsyncTask的定义</h3>
<p>AsyncTask顾名思义，异步任务，是安卓api中提供的使你可以进行后台阻塞操作并且输出结果给ui线程的封装类。</p>
<h3 id="AsyncTask的用法">AsyncTask的用法</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractModelAsyncTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ConcurrentTask</span>&lt;<span class="title">Void</span>, <span class="title">Integer</span>, <span class="title">T</span>&gt; </span>{</div><div class="line">    <span class="keyword">private</span> Exception exception;</div><div class="line">    <span class="keyword">private</span> T data;</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> T <span class="title">doInBackground</span>(Void... voids) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            data = doLoadData();</div><div class="line">            exception = <span class="keyword">null</span>;</div><div class="line">        } <span class="keyword">catch</span> (Exception e) {</div><div class="line">            data = <span class="keyword">null</span>;</div><div class="line">            exception = e;</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> getData();</div><div class="line">    }</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">doLoadData</span>() <span class="keyword">throws</span> Exception;</div><div class="line">    <span class="keyword">public</span> Exception <span class="title">getException</span>() {</div><div class="line">        <span class="keyword">return</span> exception;</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> T <span class="title">getData</span>() {</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    }</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span>(T t) {</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">if</span> (exception == <span class="keyword">null</span>) {</div><div class="line">                onSuccess(t);</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                onException(exception);</div><div class="line">            }</div><div class="line">        } <span class="keyword">catch</span> (Exception e) {</div><div class="line">            e.printStackTrace();</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                onFinally();</div><div class="line">            } <span class="keyword">catch</span> (Exception e) {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSuccess</span>(T t) {</div><div class="line">    }</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinally</span>() {</div><div class="line">    }</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onException</span>(Exception exception) {</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>用法很简单，你只需要继承AsyncTask的类并且实现两个方法，首先是doInBackground方法，这个方法是运行在后台线程中的，一般做比如获取网络数据或者文件io这种阻塞线程的操作，另一个方法是onPostExecute，它相当于一开始说的对于ui线程的输出结果，把doInBackground的结果返回给ui线程。</p>
<h3 id="AsyncTask的源码实现">AsyncTask的源码实现</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Creates a new asynchronous task. This constructor must be invoked on the UI thread.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="title">ModernAsyncTask</span>() {</div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() {</div><div class="line">        <span class="keyword">public</span> Result <span class="title">call</span>() <span class="keyword">throws</span> Exception {</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">            <span class="keyword">return</span> postResult(doInBackground(mParams));</div><div class="line">        }</div><div class="line">    };</div><div class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) {</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span>() {</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                <span class="keyword">final</span> Result result = get();</div><div class="line">                postResultIfNotInvoked(result);</div><div class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</div><div class="line">                android.util.Log.w(LOG_TAG, e);</div><div class="line">            } <span class="keyword">catch</span> (ExecutionException e) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing doInBackground()"</span>,</div><div class="line">                        e.getCause());</div><div class="line">            } <span class="keyword">catch</span> (CancellationException e) {</div><div class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">            } <span class="keyword">catch</span> (Throwable t) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing "</span></div><div class="line">                        + <span class="string">"doInBackground()"</span>, t);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    };</div><div class="line">}</div></pre></td></tr></table></figure>

<p>首先来看初始化，woker是一个callable，实现了call方法，并且被传入一个futureTask中被持有，这个FutureTask只实现了done方法，那么FutureTask具体是怎样实现的呢？</p>
<p>FutureTask中有一个内部类Sync，继承自AbstractQueuedSynchronizer，简单点可以理解为是一个线程同步器，通过维护一个int值来表示状态，子类通过实现它的方法来管理状态，它包括排他模式和共享模式两种模式，表示当前同步器是否被线程独自持有，AbstractQueuedSynchronizer比较复杂也不细讲，感兴趣的可以看<a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="external">http://ifeve.com/introduce-abstractqueuedsynchronizer/</a>，而FutureTask基本就是使用这个Sync对象操作了run，cancel和exception等操作。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">private <span class="keyword">static</span> final <span class="type">int</span> <span class="type">CORE_POOL_SIZE</span> = <span class="number">5</span>;</div><div class="line">private <span class="keyword">static</span> final <span class="type">int</span> <span class="type">MAXIMUM_POOL_SIZE</span> = <span class="number">128</span>;</div><div class="line">private <span class="keyword">static</span> final <span class="type">int</span> <span class="type">KEEP_ALIVE</span> = <span class="number">1</span>;</div><div class="line">private <span class="keyword">static</span> final <span class="type">ThreadFactory</span> sThreadFactory = new <span class="type">ThreadFactory</span>() {</div><div class="line">    private final <span class="type">AtomicInteger</span> mCount = new <span class="type">AtomicInteger</span>(<span class="number">1</span>);</div><div class="line">    public <span class="type">Thread</span> newThread(<span class="type">Runnable</span> r) {</div><div class="line">        <span class="keyword">return</span> new <span class="type">Thread</span>(r, <span class="string">"ModernAsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">    }</div><div class="line">};</div><div class="line">private <span class="keyword">static</span> final <span class="type">BlockingQueue</span>&lt;<span class="type">Runnable</span>&gt; sPoolWorkQueue =</div><div class="line">        new <span class="type">LinkedBlockingQueue</span>&lt;<span class="type">Runnable</span>&gt;(<span class="number">10</span>);</div><div class="line">/**</div><div class="line"> * <span class="type">An</span> {@link <span class="type">Executor</span>} that can be used to execute tasks <span class="keyword">in</span> parallel.</div><div class="line"> */</div><div class="line">public <span class="keyword">static</span> final <span class="type">Executor</span> <span class="type">THREAD_POOL_EXECUTOR</span></div><div class="line">        = new <span class="type">ThreadPoolExecutor</span>(<span class="type">CORE_POOL_SIZE</span>, <span class="type">MAXIMUM_POOL_SIZE</span>, <span class="type">KEEP_ALIVE</span>,</div><div class="line">                <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>, sPoolWorkQueue, sThreadFactory);</div><div class="line">private <span class="keyword">static</span> final <span class="type">int</span> <span class="type">MESSAGE_POST_RESULT</span> = <span class="number">0x1</span>;</div><div class="line">private <span class="keyword">static</span> final <span class="type">int</span> <span class="type">MESSAGE_POST_PROGRESS</span> = <span class="number">0x2</span>;</div><div class="line">private <span class="keyword">static</span> final <span class="type">InternalHandler</span> sHandler = new <span class="type">InternalHandler</span>();</div><div class="line">private <span class="keyword">static</span> volatile <span class="type">Executor</span> sDefaultExecutor = <span class="type">THREAD_POOL_EXECUTOR</span>;</div><div class="line">private final <span class="type">WorkerRunnable</span>&lt;<span class="type">Params</span>, <span class="type">Result</span>&gt; mWorker;</div><div class="line">private final <span class="type">FutureTask</span>&lt;<span class="type">Result</span>&gt; mFuture;</div><div class="line">/**</div><div class="line"> * <span class="type">This</span> <span class="keyword">method</span> can be invoked <span class="keyword">from</span> {@link <span class="comment">#doInBackground} to</span></div><div class="line"> * publish updates on the <span class="type">UI</span> thread <span class="keyword">while</span> the background computation <span class="keyword">is</span></div><div class="line"> * still running. <span class="type">Each</span> call to this <span class="keyword">method</span> will trigger the execution <span class="keyword">of</span></div><div class="line"> * {@link <span class="comment">#onProgressUpdate} on the UI thread.</span></div><div class="line"> *</div><div class="line"> * {@link <span class="comment">#onProgressUpdate} will note be called if the task has been</span></div><div class="line"> * canceled.</div><div class="line"> *</div><div class="line"> * @param values <span class="type">The</span> progress values to update the <span class="type">UI</span> <span class="keyword">with</span>.</div><div class="line"> *</div><div class="line"> * @see <span class="comment">#onProgressUpdate</span></div><div class="line"> * @see <span class="comment">#doInBackground</span></div><div class="line"> */</div><div class="line">protected final <span class="type">void</span> publishProgress(<span class="type">Progress</span>... values) {//这个方法可以在doInBackground中自行调用，会回调onProgressUpdate方法，做一些进度相关的事情。</div><div class="line">    <span class="keyword">if</span> (!isCancelled()) {</div><div class="line">        sHandler.obtainMessage(<span class="type">MESSAGE_POST_PROGRESS</span>,</div><div class="line">                new <span class="type">AsyncTaskResult</span>&lt;<span class="type">Progress</span>&gt;(this, values)).sendToTarget();</div><div class="line">    }</div><div class="line">}</div><div class="line">private <span class="type">void</span> finish(<span class="type">Result</span> <span class="literal">result</span>) {</div><div class="line">    <span class="keyword">if</span> (isCancelled()) {</div><div class="line">        onCancelled(<span class="literal">result</span>);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        onPostExecute(<span class="literal">result</span>);</div><div class="line">    }</div><div class="line">    mStatus = <span class="type">Status</span>.<span class="type">FINISHED</span>;</div><div class="line">}</div><div class="line">private <span class="keyword">static</span> class <span class="type">InternalHandler</span> extends <span class="type">Handler</span> {</div><div class="line">    @<span class="type">SuppressWarnings</span>({<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>})</div><div class="line">    @<span class="type">Override</span></div><div class="line">    public <span class="type">void</span> handleMessage(<span class="type">Message</span> msg) {</div><div class="line">        <span class="type">AsyncTaskResult</span> <span class="literal">result</span> = (<span class="type">AsyncTaskResult</span>) msg.obj;</div><div class="line">        switch (msg.what) {</div><div class="line">            <span class="keyword">case</span> <span class="type">MESSAGE_POST_RESULT</span>:</div><div class="line">                // <span class="type">There</span> <span class="keyword">is</span> only one <span class="literal">result</span></div><div class="line">                <span class="literal">result</span>.mTask.finish(<span class="literal">result</span>.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="type">MESSAGE_POST_PROGRESS</span>:</div><div class="line">                <span class="literal">result</span>.mTask.onProgressUpdate(<span class="literal">result</span>.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>除了这两个之外，还可以看到一些比较重要的初始化的类</p>
<p>1、ThreadFactory，创建一个线程，将runnable接口传入，接下来会看到哪里用到。</p>
<p>2、Executor，默认sDefaultExecutor是一个线程池，其中</p>
<p>@param corePoolSize the number of threads to keep in the pool, even if they are idle, unless {@code allowCoreThreadTimeOut} is set<br>@param maximumPoolSize the maximum number of threads to allow in the pool<br>@param keepAliveTime when the number of threads is greater than the core, this is the maximum time that excess idle threads  will wait for new tasks before terminating.<br>@param unit the time unit for the {@code keepAliveTime} argument<br>@param workQueue the queue to use for holding tasks before they are executed. This queue will hold only the {@code Runnable} tasks submitted by the {@code execute} method.<br>@param threadFactory the factory to use when the executor creates a new thread<br>可以注意到这里线程池是static的，所以不管你生成多少AsyncTask，由线程池是统一管理。</p>
<p>3、InternalHandler，后台线程对ui线程进行回调的handler<br>接下来讲一下整个过程具体是如何发生的？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> final ModernAsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span>(Executor exec,</div><div class="line">        Params... <span class="keyword">params</span>) {</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) {</div><div class="line">        <span class="keyword">switch</span> (mStatus) {</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task is already running."</span>);</div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task has already been executed "</span></div><div class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    mStatus = Status.RUNNING;</div><div class="line">    onPreExecute();</div><div class="line">    mWorker.mParams = <span class="keyword">params</span>; <span class="comment">//这个参数赋给了WorkerRunnable中的Params[] mParams;，可以在之前初始化的代码中看到，它会传递给doInBackground的参数，使用Void表示不使用这个参数</span></div><div class="line">    exec.execute(mFuture);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当我们调用AsyncTask的executeOnExecutor方法，首先会检查状态，之后会调用onPreExecute();方法，这个方法是在ui线程中的，做execute之前的一些操作，比如展示进度条。</p>
<p>exec是我们传入的Executor，拿刚才初始化时默认的sDefaultExecutor来说，将FutureTask作为参数传入。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(Runnable command) {</div><div class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Proceed in 3 steps:</div><div class="line">     *</div><div class="line">     * 1. If fewer than corePoolSize threads are running, try to</div><div class="line">     * start a new thread with the given command as its first</div><div class="line">     * task.  The call to addWorker atomically checks runState and</div><div class="line">     * workerCount, and so prevents false alarms that would add</div><div class="line">     * threads when it shouldn't, by returning false.</div><div class="line">     *</div><div class="line">     * 2. If a task can be successfully queued, then we still need</div><div class="line">     * to double-check whether we should have added a thread</div><div class="line">     * (because existing ones died since last checking) or that</div><div class="line">     * the pool shut down since entry into this method. So we</div><div class="line">     * recheck state and if necessary roll back the enqueuing if</div><div class="line">     * stopped, or start a new thread if there are none.</div><div class="line">     *</div><div class="line">     * 3. If we cannot queue task, then we try to add a new</div><div class="line">     * thread.  If it fails, we know we are shut down or saturated</div><div class="line">     * and so reject the task.</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) {</div><div class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        c = ctl.get();</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (isRunning(c) && workQueue.offer(command)) {</div><div class="line">        <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">        <span class="keyword">if</span> (! isRunning(recheck) && remove(command))</div><div class="line">            reject(command);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</div><div class="line">        reject(command);</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span>(Runnable firstTask, <span class="keyword">boolean</span> core) {</div><div class="line">    retry:</div><div class="line">    <span class="keyword">for</span> (;;) {</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line">        <span class="comment">// Check if queue empty only if necessary.</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &&</div><div class="line">            ! (rs == SHUTDOWN &&</div><div class="line">               firstTask == <span class="keyword">null</span> &&</div><div class="line">               ! workQueue.isEmpty()))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) {</div><div class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</div><div class="line">                <span class="keyword">break</span> retry;</div><div class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></div><div class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</div><div class="line">                <span class="keyword">continue</span> retry;</div><div class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    Worker w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line">    Thread t = w.thread;</div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="comment">// Recheck while holding lock.</span></div><div class="line">        <span class="comment">// Back out on ThreadFactory failure or if</span></div><div class="line">        <span class="comment">// shut down before lock acquired.</span></div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span> ||</div><div class="line">            (rs &gt;= SHUTDOWN &&</div><div class="line">             ! (rs == SHUTDOWN &&</div><div class="line">                firstTask == <span class="keyword">null</span>))) {</div><div class="line">            decrementWorkerCount();</div><div class="line">            tryTerminate();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        workers.add(w);</div><div class="line">        <span class="keyword">int</span> s = workers.size();</div><div class="line">        <span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">            largestPoolSize = s;</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        mainLock.unlock();</div><div class="line">    }</div><div class="line">    t.start();</div><div class="line">    <span class="comment">// It is possible (but unlikely) for a thread to have been</span></div><div class="line">    <span class="comment">// added to workers, but not yet started, during transition to</span></div><div class="line">    <span class="comment">// STOP, which could result in a rare missed interrupt,</span></div><div class="line">    <span class="comment">// because Thread.interrupt is not guaranteed to have any effect</span></div><div class="line">    <span class="comment">// on a non-yet-started Thread (see Thread#interrupt).</span></div><div class="line">    <span class="keyword">if</span> (runStateOf(ctl.get()) == STOP && ! t.isInterrupted())</div><div class="line">        t.interrupt();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"> </div><div class="line">    Worker(Runnable firstTask) {</div><div class="line">        <span class="keyword">this</span>.firstTask = firstTask;</div><div class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</div><div class="line">    }</div><div class="line">    <span class="javadoc">/** Delegates main run loop to outer runWorker  */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>() {</div><div class="line">        runWorker(<span class="keyword">this</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">final</span> <span class="keyword">void</span> runWorker(Worker w) {</div><div class="line">    Runnable task = w.firstTask;</div><div class="line">    w.firstTask = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) {</div><div class="line">            w.lock();</div><div class="line">            clearInterruptsForTaskRun();</div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                beforeExecute(w.thread, task);</div><div class="line">                Throwable thrown = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    task.run();</div><div class="line">                } <span class="keyword">catch</span> (RuntimeException x) {</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                } <span class="keyword">catch</span> (Error x) {</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                } <span class="keyword">catch</span> (Throwable x) {</div><div class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">                } <span class="keyword">finally</span> {</div><div class="line">                    afterExecute(task, thrown);</div><div class="line">                }</div><div class="line">            } <span class="keyword">finally</span> {</div><div class="line">                task = <span class="keyword">null</span>;</div><div class="line">                w.completedTasks++;</div><div class="line">                w.unlock();</div><div class="line">            }</div><div class="line">        }</div><div class="line">        completedAbruptly = <span class="keyword">false</span>;</div><div class="line">    } <span class="keyword">finally</span> {</div><div class="line">        processWorkerExit(w, completedAbruptly);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当前线程池中运行的线程少于corePoolSize，就会将当前task加入到woker中，addWorker方法首先会有一些循环判断和重试的操作，异常流程返回false，正常流程会创建Woker对象，并开启线程，从类图中可以看到Worker类也是一个继承自AbstractQueuedSynchronizer的子类，this.thread = getThreadFactory().newThread(this);创建的就是我们一开始初始化时候说到的ThreadFactory，run方法的实现是将当前task以及等待队列中所有的task循环提交，等待队列task的获取是在getTask方法中，这里的task.run();就会调用到FutureTask的run方法，调用sync兑现的innerRun方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="type">void</span> innerRun() {</div><div class="line">    <span class="keyword">if</span> (!compareAndSetState(<span class="type">READY</span>, <span class="type">RUNNING</span>))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    runner = <span class="type">Thread</span>.currentThread();</div><div class="line">    <span class="keyword">if</span> (getState() == <span class="type">RUNNING</span>) { // recheck after setting thread</div><div class="line">        V <span class="literal">result</span>;</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="literal">result</span> = callable.call();</div><div class="line">        } catch (<span class="type">Throwable</span> ex) {</div><div class="line">            setException(ex);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="type">set</span>(<span class="literal">result</span>);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        releaseShared(<span class="number">0</span>); // cancel</div><div class="line">    }</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="type">void</span> innerSet(V v) {</div><div class="line">    <span class="keyword">for</span> (;;) {</div><div class="line">        <span class="type">int</span> s = getState();</div><div class="line">        <span class="keyword">if</span> (s == <span class="type">RAN</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span> (s == <span class="type">CANCELLED</span>) {</div><div class="line">            // aggressively release to <span class="type">set</span> runner to null,</div><div class="line">            // <span class="keyword">in</span> <span class="keyword">case</span> we are racing <span class="keyword">with</span> a cancel request</div><div class="line">            // that will <span class="keyword">try</span> to interrupt runner</div><div class="line">            releaseShared(<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(s, <span class="type">RAN</span>)) {</div><div class="line">            <span class="literal">result</span> = v;</div><div class="line">            releaseShared(<span class="number">0</span>);</div><div class="line">            done();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>最后set(result)会调用sync的innerSet，最后调用done方法，看done方法的实现，就是将handler回调到ui线程，将result的结果onPostExecute回去。</p>
<p><img src="http://d.pcs.baidu.com/thumbnail/161aa844a30261297c50b5cbd52cfd80?fid=2265868045-250528-199519826094988&amp;time=1419667200&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-fkChVO1tB1mvud93a7mswm4aHGc%3D&amp;rt=sh&amp;expires=2h&amp;r=790902175&amp;sharesign=unknown&amp;size=c710_u500&amp;quality=100" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.linkingr/2014/04/24/AsyncTask/" data-id="0nje3stmn5vodeqm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/12/27/test/">什么是爱情</a>
          </li>
        
          <li>
            <a href="/2014/06/18/Handler-and-Looper/">Handler and Looper</a>
          </li>
        
          <li>
            <a href="/2014/05/07/Loaders/">Loaders</a>
          </li>
        
          <li>
            <a href="/2014/04/24/AsyncTask/">AsyncTask</a>
          </li>
        
          <li>
            <a href="/2013/10/17/android事件分发/">android事件分发</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 linkingr<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/script.js" type="text/javascript"></script>


  </div>
</body>
</html>