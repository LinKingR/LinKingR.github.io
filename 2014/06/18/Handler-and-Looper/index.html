<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Handler and Looper | 小林子的博客</title>
  <meta name="author" content="linkingr">

  
  <meta name="description" content="新的开始">
  
  

  <link rel="alternate" href="/atom.xml" title="小林子的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>

<body>
  <header id="header" class="inner"><nav>
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
</nav></header>
  <div id="content" class="inner"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <header>
    
  
    <h1 class="title">Handler and Looper</h1>
  

    <time datetime="2014-06-18T06:38:07.000Z">
  <span class="day">18</span><span class="month">6月</span>
</time>
  </header>
  <div class="entry-content">
    
      <p>安卓刚入门的时候就知道，系统为每个应用进程分配了一个主线程，也就是ui线程，我们也在一开始就会使用message与主线程进行通信，说起handler，looper，message甚至messageQuene，相信我们很多人都只知道并且会用，那么到底线程间通信究竟发生了什么事情，这里就来简单了解一下Handle和Looper。</p>
<p>这里首先要提到刚才提到的这四个类，Handler，Looper，Message以及MessageQueue，我们一个一个来看。</p>
<p>Handler：含义从字面意思来看是处理器，其实也是这样的，主要负责消息的发送和接受。</p>
<p>Handler提供了7个构造器，归结起来其实就是下面两个：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">Handler</span>(Callback callback, boolean <span class="keyword">async</span>) {</div><div class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) {</div><div class="line">        final Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&</div><div class="line">                (klass.getModifiers() & Modifier.STATIC) == <span class="number">0</span>) {</div><div class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        }</div><div class="line">    }</div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    }</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = <span class="keyword">async</span>;</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="title">Handler</span>(Looper looper, Callback callback, boolean <span class="keyword">async</span>) {</div><div class="line">    mLooper = looper;</div><div class="line">    mQueue = looper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = <span class="keyword">async</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到都是对四个变量进行初始化赋值，其中mLooper等下会讲，它表示当前线程的消息循环，mQueue表示MessageQueue消息队列，mCallback比较简单，就表示一个回调函数，mAsynchronous是一个boolean值，字面意思来看表示消息是否异步，它的作用我们等下看。</p>
<p>我们平时都是怎么使用Handler的呢？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Handler handler = <span class="keyword">new</span> Handler() {</div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> handleMessage(Message msg) {</div><div class="line">        <span class="comment">//做消息处理的操作</span></div><div class="line">    }</div><div class="line">}</div><div class="line">或者</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildHandler</span> <span class="inheritance"><span class="keyword">extends</span></span> <span class="title">Handler</span> </span>{</div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> handleMessage(Message msg) {</div><div class="line">        <span class="comment">//做消息处理的操作</span></div><div class="line">    }</div><div class="line">}</div><div class="line">ChildHandler handler = <span class="keyword">new</span> ChindHandler();</div><div class="line">然后调用handler.sendMessage方法，在这个handleMessage中就会接收到Message，那么这样用是否正确呢？为什么有时候会遇到Can<span class="string">'t create handler inside thread that has not called Looper.prepare()这个崩溃呢？</span></div></pre></td></tr></table></figure>

<p>带着这个问题，就要了解Looper了，那么到底什么是Looper？</p>
<p>Looper定义：消息循环，单纯这个解释大家肯定还是不能理解，再说两个重要的特性：</p>
<p><strong>1.每一个线程都只有一个Looper和一个MessageQueue。</strong></p>
<p><strong>2.每个Handler都有它所归属的线程，如果要使用Handler必须初始化Looper。</strong>ui线程的Looper叫做MainLooper，它是一个不会停止的消息循环，由系统进行初始化。</p>
<p>第二点就是解释了为什么我们可以直接使用Handler发消息，是因为系统已经为你初始化了一个消息循环，而如果你在一个自己创建的线程中使用Handler，就一定会报刚才那个异常。</p>
<p>看一下Looper中的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span>(boolean quitAllowed) {</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.<span class="keyword">get</span>() != <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    }</div><div class="line">    sThreadLocal.<span class="keyword">set</span>(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span>() {</div><div class="line">    prepare(<span class="keyword">false</span>);</div><div class="line">    synchronized (Looper.class) {</div><div class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">        }</div><div class="line">        sMainLooper = myLooper();</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span>() {</div><div class="line">    synchronized (Looper.class) {</div><div class="line">        <span class="keyword">return</span> sMainLooper;</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span>() {</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">myLooper</span>() {</div><div class="line">    <span class="keyword">return</span> sThreadLocal.<span class="keyword">get</span>();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到这里sThreadLocal是一个泛型类ThreadLocal<looper>，从它提供了set和put可以看出，它好像是一个列表，其实可以把它理解成一个特殊的map，使用set方法时，会把Looper信息与当前Thread信息绑定起来，使用get方法又会把当前线程对应的Looper取出来。</looper></p>
<p>prepareMainLooper是在应用进程初始化的过程中调用的，所以我们不可以再次调用。当你初始化一个线程时，它本身是不带消息循环的，比如主线程可以处理各个线程发来的消息，但是你new的这个线程，如果什么都不做，是无法接收消息的，那么如何把一个普通线程转化为一个Looper线程呢？看下面一段代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="at_rule">@Override<span class="preprocessor"></span></span></div><div class="line">public<span class="preprocessor"> void</span><span class="preprocessor"> run</span>() {</div><div class="line">    <span class="comment">// 将当前线程初始化为Looper线程</span></div><div class="line">    <span class="comment">// Looper.prepare();</span></div><div class="line">     </div><div class="line">    <span class="comment">// ...其他处理，如实例化handler</span></div><div class="line">    1<span class="value">: Handler handler = new <span class="function">Handler</span>();</span></div><div class="line">    2<span class="value">: Hanlder handler = new <span class="function">Handler</span>(Looper.<span class="function">getMainLooper</span>());</span></div><div class="line">    3<span class="value">: Hanlder handler = new <span class="function">Handler</span>(Looper.<span class="function">myLooper</span>());</span></div><div class="line">     </div><div class="line">    <span class="comment">// 开始循环处理消息队列</span></div><div class="line">    <span class="comment">// Looper.loop();</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到这里注释的代码，就是把一个线程变成Looper线程的关键代码，如果这两行代码被注释，1和3的初始化都会异常，而2会正常，因为2传入Handler的是主线程Looper，这样其实相当于Handler是在主线程中，跟当前线程无关，而1和3表示Handler处于当前线程中，必须在Handler初始化之前调用prepare()，并在之后开启消息循环。这样Handler才能接收和处理消息。Looper线程的Handler初始化也可以放在ui线程中，但必须在Looper线程start之后，并且将thread.getLooper()传入Handler中。</p>
<p>通过以上可以看出，Handler的归属线程取决于你传入的Looper是在哪个线程，如果不传，就是当前线程。<br>接下来，就需要分析消息循环和消息队列了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public static void loop() { //有部分代码被我省略</div><div class="line">    final Looper me = myLooper(); //取出当前Looper</div><div class="line">    <span class="keyword">if</span> (me == null) {</div><div class="line">        throw new RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    }</div><div class="line">    final MessageQueue queue = me.mQueue; //从Looper中取出消息队列</div><div class="line">    <span class="keyword">...</span></div><div class="line">    <span class="keyword">for</span> (;;) { //开始循环</div><div class="line">        Message msg = queue.next(); // 从消息队列中读出下一条消息</div><div class="line">        <span class="keyword">if</span> (msg == null) {</div><div class="line">            // 如果消息为空表示当前消息循环结束，这里注意一下，不是没有消息的时候Looper就结束，因为上一行的<span class="keyword">next</span>方法是block的，只有在调用quit方法的情况下才会返回空消息</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">...</span></div><div class="line">        msg.target.dispatchMessage(msg); //消息的回调处理，target表示Handler</div><div class="line">        <span class="keyword">...</span></div><div class="line">        msg.recycle();//消息回收</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从上面代码可以看出，Looper开启消息循环后，会进入一个死循环，注意这里不是无限循环哦，next这个方法是会block线程的，也就是当有消息的时候next方法才会返回message并且处理它，没有消息就不返回卡住啦，所以你一定好奇next里面做了什么，来看～</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">Message <span class="keyword">next</span>() {</div><div class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>;  <span class="comment">//idleHandler这个东西很有意思，它在每次调用next读取消息的之前会让你做一些你想做的操作，等下看</span></div><div class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>; <span class="comment">//字面理解是下一次的一个超时时间，它其实的意思是消息延迟，比如说你发了一个3秒后才会响应的消息，就是从这个int值体现的</span></div><div class="line">        <span class="keyword">for</span> (;;) { <span class="comment">//进入循环</span></div><div class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) {</div><div class="line">                Binder.flushPendingCommands(); <span class="comment">//不知道干嘛的</span></div><div class="line">            }</div><div class="line">             </div><div class="line">            nativePollOnce(mPtr, nextPollTimeoutMillis); <span class="comment">//native方法，这个方法叼啦，它最重要的作用就是把线程block住，两种情况会让block结束，1.这里传入的超时时间。2.某些主动触发。</span></div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">                Message prevMsg = <span class="keyword">null</span>;</div><div class="line">                Message msg = mMessages; </div><div class="line"><span class="comment">//MessageQueue里面有个mMessages，它是个Message，表示当前需要处理的消息，那么消息队列从何而来呢？在Message里面，是我们大学里写过太多的c链表，在Message里面有个next的Message对象，指向下一个Message，所以这是一个单向链表，并且按照Message的时间顺序。</span></div><div class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> && msg.target == <span class="keyword">null</span>) { </div><div class="line"><span class="comment">//记不记得刚才说过mAsynchronous这个东西，它就在这里起作用了，Looper里面提供一个方法postSyncBarrier()，它的意思是设置一个</span></div><div class="line">Barrier，它也是一个消息，但是是一个没有target的消息，执行postSyncBarrier方法会把它放置在消息队列中，这里就是对这种消息进行处理，当处理到这样的消息时，就会阻塞其他消息，只有mAsynchronous设为<span class="keyword">true</span>的才会处理，其他消息处于等待。如果没有设置Barrier则mAsynchronous和这里的代码都没有意义。</div><div class="line">                    <span class="keyword">do</span> {</div><div class="line">                        prevMsg = msg;</div><div class="line">                        msg = msg.<span class="keyword">next</span>;</div><div class="line">                    } <span class="keyword">while</span> (msg != <span class="keyword">null</span> && !msg.isAsynchronous());<span class="comment">//找到第一个isAsynchronous为true的消息</span></div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) {<span class="comment">// 得到当前需要处理的消息，一般是队列的第一条，也有可能不是。</span></div><div class="line">                    <span class="keyword">if</span> (now &lt; msg.when) { <span class="comment">//如果当前时间小于消息时间，就设置一个超时</span></div><div class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                    } <span class="keyword">else</span> { <span class="comment">//将需要处理的消息返回</span></div><div class="line">                        mBlocked = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) {</div><div class="line">                            prevMsg.<span class="keyword">next</span> = msg.<span class="keyword">next</span>;</div><div class="line">                        } <span class="keyword">else</span> {</div><div class="line">                            mMessages = msg.<span class="keyword">next</span>;</div><div class="line">                        }</div><div class="line">                        msg.<span class="keyword">next</span> = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                        msg.markInUse();</div><div class="line">                        <span class="keyword">return</span> msg;</div><div class="line">                    }</div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>; <span class="comment">//nextPollTimeoutMillis设未-1表示无限delay，只能通过其他触发</span></div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (mQuitting) {</div><div class="line">                    dispose();</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//只有quit的时候才会返回null</span></div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></div><div class="line">                        && (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) { <span class="comment">//当pendingIdleHandlerCount为-1也就是上次消息循环结束，又进入next方法等待消息并且当前没有Message需要处理时，会把mIdleHandlers里注册的Handler执行一遍，注意这里在每一次next进入到return结果只会执行一遍。</span></div><div class="line">                    pendingIdleHandlerCount = mIdleHandlers.<span class="keyword">size</span>();</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) {</div><div class="line">                    mBlocked = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">continue</span>; <span class="comment">//没有的话就直接继续循环</span></div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) {</div><div class="line">                    mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</div><div class="line">                }</div><div class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">            }</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) {</div><div class="line">                <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">                mPendingIdleHandlers[i] = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">try</span> {</div><div class="line">                    keep = idler.queueIdle();</div><div class="line">                } <span class="keyword">catch</span> (Throwable t) {</div><div class="line">                    Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (!keep) {</div><div class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">                        mIdleHandlers.remove(idler);</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">            pendingIdleHandlerCount = <span class="number">0</span>;</div><div class="line">            nextPollTimeoutMillis = <span class="number">0</span>;<span class="comment">//执行之后，会初始化nextPollTimeoutMillis＝0是因为系统认为这个执行过程中有可能会有新的消息插入了，所以需要再重新取一遍消息</span></div><div class="line">        }</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>所以可以看到这个核心函数的关键在于nativePollOnce方法的block，可以这样理解它，每次next都一定会取到一个Message，里面会有一个无限循环，取到当前队列中的第一个需要处理的Message，如果为空，则表示当前消息队列未空，设置nextPollTimeoutMillis为-1，线程无限block，需要通过其他方式唤醒，如果不为空，则判断时间是否已到，没有到就会在算出timeout的时间，否则就将Message返回，然后处理消息，再进入下一次next循环处理消息的生命周期中。</p>
<p>对于消息循环和消息队列理解清楚了，就差最后一步了，发消息的时候发生了什么呢？<br>首先讲一下Message，含义是消息，Message要讲的就是里面的一个静态变量Message，Message本身会维护一个链表，用来保存那些被处理过的消息，可以进行复用，所以我们尽量不要用new Message的方法来使用Message，而尽量使用Message.obtain系列方法，它会对已回收的Message进行复用，减少内存开销，如果每次都new Message，就会把这个回收的链表整的很长。</p>
<p>我们使用Message.obtain(handler).sendToTarget()方法，handler.sendEmptyMessage系列方法或者post(Runnable)方法发送消息最后所有的方法都会走到一个sendMessageAtTime(Message msg, long uptimeMillis)方法中，最后都会调用到enqueueMessage，这是MessageQuene中的方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> enqueueMessage(Message msg, <span class="keyword">long</span> when) {</div><div class="line">    <span class="keyword">if</span> (msg.isInUse()) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) {</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Message must have a target."</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">        <span class="keyword">if</span> (mQuitting) {</div><div class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">            Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">boolean</span> needWake;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) { <span class="comment">//当前mMessages为空或者传入的msg处理时间小于mMessages的处理时间，就把它放在mMessages的前面</span></div><div class="line">            msg.<span class="keyword">next</span> = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;<span class="comment">// mBlocked标志当前是否处于block状态，如果处于block状态就需要唤醒。</span></div><div class="line">        } <span class="keyword">else</span> { <span class="comment">//当前队列不为空，并且需要处理的消息时间延后，则找到这个消息所属的位置，将其插入</span></div><div class="line">            needWake = mBlocked && p.target == <span class="keyword">null</span> && msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">            <span class="keyword">for</span> (;;) {</div><div class="line">                prev = p;</div><div class="line">                p = p.<span class="keyword">next</span>;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) { <span class="comment">//找到，退出</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (needWake && p.isAsynchronous()) {</div><div class="line">                    needWake = <span class="keyword">false</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            msg.<span class="keyword">next</span> = p; <span class="comment">//将msg插入到p和prev之间</span></div><div class="line">            prev.<span class="keyword">next</span> = msg;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (needWake) {</div><div class="line">            nativeWake(mPtr); <span class="comment">//这个native方法对应于nativePollOnce，会将这个方法唤醒并返回。</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样看来是不是就清楚了，handler的send只负责向消息队列中插入消息，并通知native层，我有消息啦，Looper负责消息循环，查询当前是否有消息需要处理，如果有就返回，如果没有就等待通知。</p>
<p>那么现在还有一个问题，这个block为什么不会block ui线程呢？其实并不是不block ui线程，而是因为ui线程本身就是block的。看系统是怎么做的？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Looper<span class="built_in">.</span>prepareMainLooper();</div><div class="line">ActivityThread <span class="keyword">thread</span> <span class="subst">=</span> <span class="literal">new</span> ActivityThread();</div><div class="line"><span class="keyword">thread</span><span class="built_in">.</span>attach(<span class="literal">false</span>);</div><div class="line"><span class="keyword">if</span> (sMainThreadHandler <span class="subst">==</span> <span class="built_in">null</span>) {</div><div class="line">    sMainThreadHandler <span class="subst">=</span> <span class="keyword">thread</span><span class="built_in">.</span>getHandler();</div><div class="line">}</div><div class="line">AsyncTask<span class="built_in">.</span>init();</div><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) {</div><div class="line">    Looper<span class="built_in">.</span>myLooper()<span class="built_in">.</span>setMessageLogging(<span class="literal">new</span></div><div class="line">            LogPrinter(<span class="keyword">Log</span><span class="built_in">.</span>DEBUG, <span class="string">"ActivityThread"</span>));</div><div class="line">}</div><div class="line">Looper<span class="built_in">.</span><span class="keyword">loop</span>();</div><div class="line">throw <span class="literal">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</div></pre></td></tr></table></figure>

<p>其实主线程就是一个被block住的线程，这个sMainHandler是一个很庞大的handler，里面包含了对activity，service等系统组件的控制，所以可以看到，其实所有比如页面开启、结束，内存回收，服务开启、绑定等等的操作，你的每一次点击，滑动都是通过消息触发并执行的，消息触发机制实现了整个安卓交互的过程，这点是不是很叼！</p>
<p><img src="http://d.pcs.baidu.com/thumbnail/00ce2c7a7fc70621c9d0c2b7c2a60f4b?fid=2265868045-250528-236330621244287&amp;time=1419667200&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-USvobe%2FEcC3jN9sSzktqs1zHZgY%3D&amp;rt=sh&amp;expires=2h&amp;r=516646235&amp;sharesign=unknown&amp;size=c710_u500&amp;quality=100" alt=""></p>

    
    
    <footer class="meta">
      
      
      
    </footer>
    
  </div>
  
</article></div>
  <footer id="footer" class="inner"><div class="social alignright">
  
  
  
  
  <a class="rss" href="/atom.xml" title="RSS">RSS</a>
</div>
<p>
  
  &copy; 2014 linkingr
  
</p>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id="phasebeam">
  <canvas></canvas>
  <canvas></canvas>
  <canvas></canvas>
</div>
<script src="/js/phasebeam.js"></script>
</body>
</html>